<?php

namespace App\Http\Controllers\web;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Http\JsonResponse;
use Inertia\Response as InertiaResponse;
use App\Http\Controllers\web\PageController; // Ensure correct namespace

class WebSearchController extends Controller
{
    /**
     * Search public pages and return advanced AI-generated results.
     */
    public function search(Request $request): JsonResponse
    {
        try {
            $query = strtolower(trim($request->input('query')));
            if (!$query) {
                return response()->json(['error' => 'Search query is required'], 400);
            }
            Log::info('Search Query:', ['query' => $query]);

            // Define public pages to search â€“ keys must match your PageController mapping.
            $pages = [
                'about',
                'our-story',
                'contact',
                'real-estate',
                'private-equity',
                'agendaevent',
                'masterclass',
                'webinar'
            ];
            $results = [];

            // Load searchable configuration file from config/searchable.php
            $searchableConfig = config('searchable');

            foreach ($pages as $page) {
                try {
                    // Render the page via PageController.
                    $response = app(PageController::class)->renderPage($page);

                    // Convert Inertia responses to HTTP responses if needed.
                    if ($response instanceof InertiaResponse) {
                        $httpResponse = $response->toResponse($request);
                        $rawContent = $httpResponse->getContent();
                    } elseif (method_exists($response, 'getContent')) {
                        $rawContent = $response->getContent();
                    } else {
                        $rawContent = json_encode($response);
                    }

                    // Filter out technical-related content in a less destructive way.
                    $filteredRawContent = $this->filterTechnicalInfo($rawContent);

                    // Convert the filtered content to plain text.
                    $plainContent = $this->htmlToPlainText($filteredRawContent);
                } catch (\Exception $e) {
                    Log::error("Failed to load page: {$page} - " . $e->getMessage());
                    continue;
                }

                // Check if the plain text contains the search query.
                if (stripos($plainContent, $query) !== false) {
                    $url = route('dynamic.page', ['page' => $page]);
                    $snippet = $this->extractSnippet($plainContent, $query);
                    $summary = $this->summarizeSnippet($snippet);

                    // Determine the page title from the searchable config if available.
                    $pageTitle = ucfirst($page);
                    $locale = app()->getLocale();
                    if (isset($searchableConfig[$page])) {
                        if (isset($searchableConfig[$page][$locale]['hero_title'])) {
                            $pageTitle = $searchableConfig[$page][$locale]['hero_title'];
                        } elseif (isset($searchableConfig[$page]['heroTitle'])) {
                            $pageTitle = $searchableConfig[$page]['heroTitle'];
                        }
                    }

                    $results[] = [
                        'page'        => $pageTitle,
                        'description' => $summary,
                        'url'         => $url,
                    ];
                }
            }

            if (empty($results)) {
                return response()->json([
                    'query'   => $query,
                    'results' => [],
                    'message' => 'No results found. Please try a different search term.',
                ]);
            }

            return response()->json([
                'query'   => $query,
                'results' => $results,
            ]);
        } catch (\Exception $e) {
            Log::error('Search Error: ' . $e->getMessage());
            return response()->json([
                'error'   => 'Internal Server Error',
                'message' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Filter out technical-related content from the raw response by replacing keywords instead of removing full lines.
     */
    private function filterTechnicalInfo(string $content): string
    {
        $technicalKeywords = [
            'Ziggy',
            'debugbar',
            'clockwork',
            'asset(',
            'route(',
            'DEBUG',
            'debug',
            'Debug information:',
            'Route listing:',
            'Generated by',
            '/css/',
            '/js/',
            '/storage/',
            '/images/',
            '<!--',
            '-->',
            // Additional technical keywords to filter out common routes, HTTP methods, and coding references.
            'GET ',
            'POST ',
            'PUT ',
            'DELETE ',
            'PATCH ',
            'OPTIONS ',
            'HTTP/',
            'ssh',
            'vite',
            'react',
            'vue',
            'laravel',
            'dynamic',       // caution: generic word, but added as requested.
            'HTTP methods'
        ];

        // Replace each technical keyword with an empty string (case-insensitive).
        foreach ($technicalKeywords as $keyword) {
            $content = str_ireplace($keyword, '', $content);
        }

        // Collapse multiple newlines to a single newline.
        $content = preg_replace("/[\r\n]+/", "\n", $content);

        return trim($content);
    }

    /**
     * Convert HTML to plain text using DOMDocument.
     */
    private function htmlToPlainText(string $html): string
    {
        libxml_use_internal_errors(true);
        $doc = new \DOMDocument();
        $html = mb_convert_encoding($html, 'HTML-ENTITIES', 'UTF-8');
        if ($doc->loadHTML($html)) {
            $text = $doc->textContent;
            return trim($text);
        }
        return trim(strip_tags($html));
    }

    /**
     * Extracts a snippet of text around the search query.
     */
    private function extractSnippet(string $content, string $query, int $window = 200): string
    {
        $position = mb_stripos($content, $query);
        if ($position === false) {
            return "";
        }
        $start = max(0, $position - $window);
        $end = min(mb_strlen($content), $position + mb_strlen($query) + $window);
        return mb_substr($content, $start, $end - $start);
    }

    /**
     * Summarize the snippet using OpenAI GPT-3.5 Turbo (limit to ~30 words).
     * If the snippet contains code or IT-related content, skip summarization.
     */
    private function summarizeSnippet(string $snippet): string
    {
        $trimmedSnippet = trim($snippet);
        if (empty($trimmedSnippet)) {
            return "";
        }

        // Check for common code markers or IT-related patterns.
        if (preg_match('/<\?php|<code>|<\/code>|function\s+\w+\s*\(|public\s+function|class\s+\w+|GET\s+\/|POST\s+\/|PUT\s+\/|DELETE\s+\/|HTTP\//i', $trimmedSnippet)) {
            // Return the original snippet if it seems to be code or technical content.
            return $trimmedSnippet;
        }

        try {
            $openAi = \OpenAI::client(env('OPENAI_API_KEY'));
            $prompt = "Summarize the following text in a friendly, concise manner in no more than 30 words. Ignore any technical or debug information and focus only on describing the content that a visitor would see on the page:\n\n" . $trimmedSnippet;
            $response = $openAi->chat()->create([
                'model'       => 'gpt-3.5-turbo',
                'messages'    => [
                    ['role' => 'system', 'content' => $prompt],
                ],
                'max_tokens'  => 60,
                'temperature' => 0.5,
            ]);
            $summary = $response['choices'][0]['message']['content'] ?? '';
            $summary = trim($summary);
            if (empty($summary) || stripos($summary, "i'm sorry") !== false) {
                return $trimmedSnippet;
            }
            return $summary;
        } catch (\Exception $e) {
            Log::error("OpenAI Summarization Error: " . $e->getMessage());
            return $trimmedSnippet;
        }
    }
}
